# Proof Analysis Report

**Generated:** 2026-02-21 15:22:10

## Raw Code

```lean
import Mathlib
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat

lemma aime_1983_p3_1_1
    (f : ℝ → ℝ)
    (h₀ : ∀ x : ℝ,
        f x =
        x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45))
    (h₁ : Fintype (↑(f ⁻¹' {0}) : Type)) :
    ∏ x ∈ (f ⁻¹' {0}).toFinset, x = 20 := by
  have h2 : ∀ x : ℝ, f x = 0 ↔ x = -9 + √61 ∨ x = -9 - √61 := by
    intro x
    constructor
    · -- Assume f(x) = 0, prove x = -9 ± √61
      intro hx
      have hfx : f x = x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45) := h₀ x
      rw [hfx] at hx
      have h_eq : x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45) = 0 := hx
      have h1 : 2 * √(x ^ 2 + 18 * x + 45) = x ^ 2 + 18 * x + 30 := by linarith
      have h2 : x ^ 2 + 18 * x + 45 ≥ 0 := by
        nlinarith [Real.sqrt_nonneg (x ^ 2 + 18 * x + 45)]
      have h3 : √(x ^ 2 + 18 * x + 45) ≥ 0 := Real.sqrt_nonneg (x ^ 2 + 18 * x + 45)
      have h4 : x ^ 2 + 18 * x + 30 ≥ 0 := by nlinarith
      have h5 : x ^ 2 + 18 * x + 30 = 2 * √(x ^ 2 + 18 * x + 45) := by linarith
      have h6 : (x ^ 2 + 18 * x + 30) ^ 2 = 4 * (x ^ 2 + 18 * x + 45) := by
        have hsq : (2 * √(x ^ 2 + 18 * x + 45)) ^ 2 = 4 * (x ^ 2 + 18 * x + 45) := by
          calc
            (2 * √(x ^ 2 + 18 * x + 45)) ^ 2 = 4 * (√(x ^ 2 + 18 * x + 45) ^ 2) := by ring
            _ = 4 * (x ^ 2 + 18 * x + 45) := by rw [Real.sq_sqrt h2]
        rw [← h5] at hsq
        nlinarith
      have h7 : (x - (-9 + √61)) * (x - (-9 - √61)) = 0 := by
        ring_nf
        nlinarith [h6, Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
      cases' (mul_eq_zero.mp h7) with h8 h9
      · left
        linarith
      · right
        linarith
    · -- Assume x = -9 ± √61, prove f(x) = 0
      rintro (h | h)
      · -- x = -9 + √61
        rw [h]
        have h1 : (-9 + √61) ^ 2 + (18 * (-9 + √61) + 30) - 2 * √((-9 + √61) ^ 2 + 18 * (-9 + √61) + 45) = 0 := by
          have h2 : (-9 + √61) ^ 2 + 18 * (-9 + √61) + 30 = 10 := by
            ring_nf
            nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
          have h3 : √((-9 + √61) ^ 2 + 18 * (-9 + √61) + 45) = 5 := by
            rw [show (-9 + √61) ^ 2 + 18 * (-9 + √61) + 45 = 25 by ring_nf; nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]]
            exact Real.sqrt_eq_cases.2 (by norm_num)
          linarith
        rw [h1]
      · -- x = -9 - √61
        rw [h]
        have h1 : (-9 - √61) ^ 2 + (18 * (-9 - √61) + 30) - 2 * √((-9 - √61) ^ 2 + 18 * (-9 - √61) + 45) = 0 := by
          have h2 : (-9 - √61) ^ 2 + 18 * (-9 - √61) + 30 = 10 := by
            ring_nf
            nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
          have h3 : √((-9 - √61) ^ 2 + 18 * (-9 - √61) + 45) = 5 := by
            rw [show (-9 - √61) ^ 2 + 18 * (-9 - √61) + 45 = 25 by ring_nf; nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]]
            exact Real.sqrt_eq_cases.2 (by norm_num)
          linarith
        rw [h1]
  have h3 : (f ⁻¹' {0}).toFinset = {(-9 + √61), (-9 - √61)} := by
    ext x
    simp [Set.mem_preimage, Set.mem_singleton_iff]
    constructor
    · -- Show that if f(x) = 0, then x ∈ { -9+√61, -9-√61 }
      intro hfx
      have h_eq : f x = 0 := hfx
      have h4 : x = -9 + √61 ∨ x = -9 - √61 := h2 x
      tauto
    · -- Show that if x ∈ { -9+√61, -9-√61 }, then f(x) = 0
      rintro (h | h)
      · -- x = -9 + √61
        rw [h]
        exact (h2 (-9 + √61)).left
      · -- x = -9 - √61
        rw [h]
        exact (h2 (-9 - √61)).right
  rw [h3]
  rw [Finset.prod_pair]
  have h4 : (-9 + √61) ≠ (-9 - √61) := by
    have h5 : √61 > 0 := Real.sqrt_pos.mpr (by norm_num : (61 : ℝ) > 0)
    linarith [h5]
  simp [h4]
  linarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
```

## Parsed Tree Structure

```
1:import Mathlib
2:set_option maxHeartbeats 0
3:open BigOperators Real Nat Topology Rat
4:lemma aime_1983_p3_1_1
5:    (f : ℝ → ℝ)
6:    (h₀ : ∀ x : ℝ,
7:        f x =
8:        x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45))
9:    (h₁ : Fintype (↑(f ⁻¹' {0}) : Type)) :
10:    ∏ x ∈ (f ⁻¹' {0}).toFinset, x = 20 := by
11:    have h2 : ∀ x : ℝ, f x = 0 ↔ x = -9 + √61 ∨ x = -9 - √61 := by
12:        intro x
13:        constructor
14:        · -- Assume f(x) = 0, prove x = -9 ± √61
15:            intro hx
16:            have hfx : f x = x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45) := h₀ x
17:            rw [hfx] at hx
18:            have h_eq : x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45) = 0 := hx
19:            have h1 : 2 * √(x ^ 2 + 18 * x + 45) = x ^ 2 + 18 * x + 30 := by linarith
20:            have h2 : x ^ 2 + 18 * x + 45 ≥ 0 := by
21:                nlinarith [Real.sqrt_nonneg (x ^ 2 + 18 * x + 45)]
22:            have h3 : √(x ^ 2 + 18 * x + 45) ≥ 0 := Real.sqrt_nonneg (x ^ 2 + 18 * x + 45)
23:            have h4 : x ^ 2 + 18 * x + 30 ≥ 0 := by nlinarith
24:            have h5 : x ^ 2 + 18 * x + 30 = 2 * √(x ^ 2 + 18 * x + 45) := by linarith
25:            have h6 : (x ^ 2 + 18 * x + 30) ^ 2 = 4 * (x ^ 2 + 18 * x + 45) := by
26:                have hsq : (2 * √(x ^ 2 + 18 * x + 45)) ^ 2 = 4 * (x ^ 2 + 18 * x + 45) := by
27:                    calc
28:                        (2 * √(x ^ 2 + 18 * x + 45)) ^ 2 = 4 * (√(x ^ 2 + 18 * x + 45) ^ 2) := by ring
29:                        _ = 4 * (x ^ 2 + 18 * x + 45) := by rw [Real.sq_sqrt h2]
30:                rw [← h5] at hsq
31:                nlinarith
32:            have h7 : (x - (-9 + √61)) * (x - (-9 - √61)) = 0 := by
33:                ring_nf
34:                nlinarith [h6, Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
35:            cases' (mul_eq_zero.mp h7) with h8 h9
36:            · left
37:                linarith
38:            · right
39:                linarith
40:        · -- Assume x = -9 ± √61, prove f(x) = 0
41:            rintro (h | h)
42:            · -- x = -9 + √61
43:                rw [h]
44:                have h1 : (-9 + √61) ^ 2 + (18 * (-9 + √61) + 30) - 2 * √((-9 + √61) ^ 2 + 18 * (-9 + √61) + 45) = 0 := by
45:                    have h2 : (-9 + √61) ^ 2 + 18 * (-9 + √61) + 30 = 10 := by
46:                        ring_nf
47:                        nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
48:                    have h3 : √((-9 + √61) ^ 2 + 18 * (-9 + √61) + 45) = 5 := by
49:                        rw [show (-9 + √61) ^ 2 + 18 * (-9 + √61) + 45 = 25 by ring_nf; nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]]
50:                        exact Real.sqrt_eq_cases.2 (by norm_num)
51:                    linarith
52:                rw [h1]
53:            · -- x = -9 - √61
54:                rw [h]
55:                have h1 : (-9 - √61) ^ 2 + (18 * (-9 - √61) + 30) - 2 * √((-9 - √61) ^ 2 + 18 * (-9 - √61) + 45) = 0 := by
56:                    have h2 : (-9 - √61) ^ 2 + 18 * (-9 - √61) + 30 = 10 := by
57:                        ring_nf
58:                        nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
59:                    have h3 : √((-9 - √61) ^ 2 + 18 * (-9 - √61) + 45) = 5 := by
60:                        rw [show (-9 - √61) ^ 2 + 18 * (-9 - √61) + 45 = 25 by ring_nf; nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]]
61:                        exact Real.sqrt_eq_cases.2 (by norm_num)
62:                    linarith
63:                rw [h1]
64:    have h3 : (f ⁻¹' {0}).toFinset = {(-9 + √61), (-9 - √61)} := by
65:        ext x
66:        simp [Set.mem_preimage, Set.mem_singleton_iff]
67:        constructor
68:        · -- Show that if f(x) = 0, then x ∈ { -9+√61, -9-√61 }
69:            intro hfx
70:            have h_eq : f x = 0 := hfx
71:            have h4 : x = -9 + √61 ∨ x = -9 - √61 := h2 x
72:            tauto
73:        · -- Show that if x ∈ { -9+√61, -9-√61 }, then f(x) = 0
74:            rintro (h | h)
75:            · -- x = -9 + √61
76:                rw [h]
77:                exact (h2 (-9 + √61)).left
78:            · -- x = -9 - √61
79:                rw [h]
80:                exact (h2 (-9 - √61)).right
81:    rw [h3]
82:    rw [Finset.prod_pair]
83:    have h4 : (-9 + √61) ≠ (-9 - √61) := by
84:        have h5 : √61 > 0 := Real.sqrt_pos.mpr (by norm_num : (61 : ℝ) > 0)
85:        linarith [h5]
86:    simp [h4]
87:    linarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
```

## Tree Code

```lean
import Mathlib
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat
lemma aime_1983_p3_1_1
    (f : ℝ → ℝ)
    (h₀ : ∀ x : ℝ,
        f x =
        x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45))
    (h₁ : Fintype (↑(f ⁻¹' {0}) : Type)) :
    ∏ x ∈ (f ⁻¹' {0}).toFinset, x = 20 := by
    have h2 : ∀ x : ℝ, f x = 0 ↔ x = -9 + √61 ∨ x = -9 - √61 := by
        intro x
        constructor
        · -- Assume f(x) = 0, prove x = -9 ± √61
            intro hx
            have hfx : f x = x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45) := h₀ x
            rw [hfx] at hx
            have h_eq : x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45) = 0 := hx
            have h1 : 2 * √(x ^ 2 + 18 * x + 45) = x ^ 2 + 18 * x + 30 := by linarith
            have h2 : x ^ 2 + 18 * x + 45 ≥ 0 := by
                nlinarith [Real.sqrt_nonneg (x ^ 2 + 18 * x + 45)]
            have h3 : √(x ^ 2 + 18 * x + 45) ≥ 0 := Real.sqrt_nonneg (x ^ 2 + 18 * x + 45)
            have h4 : x ^ 2 + 18 * x + 30 ≥ 0 := by nlinarith
            have h5 : x ^ 2 + 18 * x + 30 = 2 * √(x ^ 2 + 18 * x + 45) := by linarith
            have h6 : (x ^ 2 + 18 * x + 30) ^ 2 = 4 * (x ^ 2 + 18 * x + 45) := by
                have hsq : (2 * √(x ^ 2 + 18 * x + 45)) ^ 2 = 4 * (x ^ 2 + 18 * x + 45) := by
                    calc
                        (2 * √(x ^ 2 + 18 * x + 45)) ^ 2 = 4 * (√(x ^ 2 + 18 * x + 45) ^ 2) := by ring
                        _ = 4 * (x ^ 2 + 18 * x + 45) := by rw [Real.sq_sqrt h2]
                rw [← h5] at hsq
                nlinarith
            have h7 : (x - (-9 + √61)) * (x - (-9 - √61)) = 0 := by
                ring_nf
                nlinarith [h6, Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
            cases' (mul_eq_zero.mp h7) with h8 h9
            · left
                linarith
            · right
                linarith
        · -- Assume x = -9 ± √61, prove f(x) = 0
            rintro (h | h)
            · -- x = -9 + √61
                rw [h]
                have h1 : (-9 + √61) ^ 2 + (18 * (-9 + √61) + 30) - 2 * √((-9 + √61) ^ 2 + 18 * (-9 + √61) + 45) = 0 := by
                    have h2 : (-9 + √61) ^ 2 + 18 * (-9 + √61) + 30 = 10 := by
                        ring_nf
                        nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
                    have h3 : √((-9 + √61) ^ 2 + 18 * (-9 + √61) + 45) = 5 := by
                        rw [show (-9 + √61) ^ 2 + 18 * (-9 + √61) + 45 = 25 by ring_nf; nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]]
                        exact Real.sqrt_eq_cases.2 (by norm_num)
                    linarith
                rw [h1]
            · -- x = -9 - √61
                rw [h]
                have h1 : (-9 - √61) ^ 2 + (18 * (-9 - √61) + 30) - 2 * √((-9 - √61) ^ 2 + 18 * (-9 - √61) + 45) = 0 := by
                    have h2 : (-9 - √61) ^ 2 + 18 * (-9 - √61) + 30 = 10 := by
                        ring_nf
                        nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
                    have h3 : √((-9 - √61) ^ 2 + 18 * (-9 - √61) + 45) = 5 := by
                        rw [show (-9 - √61) ^ 2 + 18 * (-9 - √61) + 45 = 25 by ring_nf; nlinarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]]
                        exact Real.sqrt_eq_cases.2 (by norm_num)
                    linarith
                rw [h1]
    have h3 : (f ⁻¹' {0}).toFinset = {(-9 + √61), (-9 - √61)} := by
        ext x
        simp [Set.mem_preimage, Set.mem_singleton_iff]
        constructor
        · -- Show that if f(x) = 0, then x ∈ { -9+√61, -9-√61 }
            intro hfx
            have h_eq : f x = 0 := hfx
            have h4 : x = -9 + √61 ∨ x = -9 - √61 := h2 x
            tauto
        · -- Show that if x ∈ { -9+√61, -9-√61 }, then f(x) = 0
            rintro (h | h)
            · -- x = -9 + √61
                rw [h]
                exact (h2 (-9 + √61)).left
            · -- x = -9 - √61
                rw [h]
                exact (h2 (-9 - √61)).right
    rw [h3]
    rw [Finset.prod_pair]
    have h4 : (-9 + √61) ≠ (-9 - √61) := by
        have h5 : √61 > 0 := Real.sqrt_pos.mpr (by norm_num : (61 : ℝ) > 0)
        linarith [h5]
    simp [h4]
    linarith [Real.sq_sqrt (show 0 ≤ 61 by norm_num : (61 : ℝ) ≥ 0)]
```

## Initial Verification

**Status:** ❌ FAIL

### Errors

```bash
- **Line 36:** unsolved goals
case mp.inl.h
f : ℝ → ℝ
h₀ : ∀ (x : ℝ), f x = x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45)
h₁ : Fintype ↑(f ⁻¹' {0})
x : ℝ
hx : x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45) = 0
hfx : f x = x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45)
h_eq : x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45) = 0
h1 : 2 * √(x ^ 2 + 18 * x + 45) = x ^ 2 + 18 * x + 30
h2 : x ^ 2 + 18 * x + 45 ≥ 0
h3 : √(x ^ 2 + 18 * x + 45) ≥ 0
h4 : x ^ 2 + 18 * x + 30 ≥ 0
h5 : x ^ 2 + 18 * x + 30 = 2 * √(x ^ 2 + 18 * x + 45)
h6 : (x ^ 2 + 18 * x + 30) ^ 2 = 4 * (x ^ 2 + 18 * x + 45)
h7 : (x - (-9 + √61)) * (x - (-9 - √61)) = 0
h8 : x - (-9 + √61) = 0
⊢ x = -9 + √61
- **Line 14:** unsolved goals
case mp.inr
f : ℝ → ℝ
h₀ : ∀ (x : ℝ), f x = x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45)
h₁ : Fintype ↑(f ⁻¹' {0})
x : ℝ
hx : x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45) = 0
hfx : f x = x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45)
h_eq : x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45) = 0
h1 : 2 * √(x ^ 2 + 18 * x + 45) = x ^ 2 + 18 * x + 30
h2 : x ^ 2 + 18 * x + 45 ≥ 0
h3 : √(x ^ 2 + 18 * x + 45) ≥ 0
h4 : x ^ 2 + 18 * x + 30 ≥ 0
h5 : x ^ 2 + 18 * x + 30 = 2 * √(x ^ 2 + 18 * x + 45)
h6 : (x ^ 2 + 18 * x + 30) ^ 2 = 4 * (x ^ 2 + 18 * x + 45)
h7 : (x - (-9 + √61)) * (x - (-9 - √61)) = 0
h9 : x - (-9 - √61) = 0
⊢ x = -9 + √61 ∨ x = -9 - √61
- **Line 11:** unsolved goals
case mpr
f : ℝ → ℝ
h₀ : ∀ (x : ℝ), f x = x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45)
h₁ : Fintype ↑(f ⁻¹' {0})
x : ℝ
⊢ x = -9 + √61 ∨ x = -9 - √61 → f x = 0
- **Line 10:** unsolved goals
f : ℝ → ℝ
h₀ : ∀ (x : ℝ), f x = x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45)
h₁ : Fintype ↑(f ⁻¹' {0})
h2 : ∀ (x : ℝ), f x = 0 ↔ x = -9 + √61 ∨ x = -9 - √61
⊢ ∏ x ∈ (f ⁻¹' {0}).toFinset, x = 20
- **Line 37:** unexpected identifier; expected command

```

## Sorrification Process

### Sorrified Result

```lean
import Mathlib
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat
lemma aime_1983_p3_1_1
    (f : ℝ → ℝ)
    (h₀ : ∀ x : ℝ,
        f x =
        x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45))
    (h₁ : Fintype (↑(f ⁻¹' {0}) : Type)) :
    ∏ x ∈ (f ⁻¹' {0}).toFinset, x = 20 := by
  sorry
```

## Auto Solver (ProofRepairer)

### Auto Solver Result

```lean
import Mathlib
set_option maxHeartbeats 0
open BigOperators Real Nat Topology Rat
lemma aime_1983_p3_1_1
    (f : ℝ → ℝ)
    (h₀ : ∀ x : ℝ,
        f x =
        x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45))
    (h₁ : Fintype (↑(f ⁻¹' {0}) : Type)) :
    ∏ x ∈ (f ⁻¹' {0}).toFinset, x = 20 := by
  try norm_cast ; try norm_num ; try simp_all ; try ring_nf at * ; try native_decide ; try linarith ; try nlinarith
  sorry
```

## Final Verification

- **Pass:** Yes
- **Complete:** No
## RAG Retrieval Analysis

**Found 1 sorry(s)**

### Sorry #1 (Line 12)

#### Query

```lean
f : ℝ → ℝ
h₀ : ∀ (x : ℝ), f x = x ^ 2 + (18 * x + 30) - 2 * √(x ^ 2 + 18 * x + 45)
h₁ : Fintype ↑(f ⁻¹' {0})
⊢ ∏ x ∈ (f ⁻¹' {0}).toFinset, x = 20
```

#### Retrieved 10 Premises

```lean
**[1] Set.toFinset_setOf** (Similarity: 1.5090)

@[simp]
theorem toFinset_setOf [Fintype α] (p : α → Prop) [DecidablePred p] [Fintype { x | p x }] :
    { x | p x }.toFinset = Finset.univ.filter p
**[2] Set.toFinset** (Similarity: 1.4936)

def toFinset (s : Set α) [Fintype s] : Finset α :=
  (@Finset.univ s _).map <| Function.Embedding.subtype _
**[3] Finset.prod_toFinset_eq_subtype** (Similarity: 1.4561)

@[to_additive]
theorem Finset.prod_toFinset_eq_subtype {M : Type*} [CommMonoid M] [Fintype α] (p : α → Prop)
    [DecidablePred p] (f : α → M) : ∏ a in { x | p x }.toFinset, f a = ∏ a : Subtype p, f a
**[4] Finset.subset_univ** (Similarity: 1.2906)

@[simp]
theorem subset_univ (s : Finset α) : s ⊆ univ
**[5] legendreSym.card_sqrts** (Similarity: 1.2786)

theorem card_sqrts (hp : p ≠ 2) (a : ℤ) :
    ↑{x : ZMod p | x ^ 2 = a}.toFinset.card = legendreSym p a + 1
**[6] Set.mem_toFinset** (Similarity: 1.2319)

@[simp]
theorem mem_toFinset {s : Set α} [Fintype s] {a : α} : a ∈ s.toFinset ↔ a ∈ s
**[7] Finset.univ** (Similarity: 1.2282)

def univ : Finset α :=
  @Fintype.elems α _
**[8] Finset.prod_set_coe** (Similarity: 1.2056)

@[to_additive]
theorem prod_set_coe (s : Set α) [Fintype s] : (∏ i : s, f i) = ∏ i in s.toFinset, f i
**[9] quadraticChar_card_sqrts** (Similarity: 1.1584)

theorem quadraticChar_card_sqrts (hF : ringChar F ≠ 2) (a : F) :
    ↑{x : F | x ^ 2 = a}.toFinset.card = quadraticChar F a + 1
**[10] Set.toFinset_mono** (Similarity: 1.1455)

alias ⟨_, toFinset_mono⟩ := toFinset_subset_toFinset

```

